# ADR 0001: 纯 CLI vs library+CLI

- 状态：已接受
- 日期：2026-02-21
- 决策者：CrabClaw 维护者

## 背景

CrabClaw 的目标是用 Rust 实现 bub/OpenClaw 的工作流。
我们需要选择：是将所有逻辑直接放在二进制文件中（`纯 CLI`），还是将可复用逻辑拆分到 library crate，配合一个薄 CLI 层（`library+CLI`）。

## 决策驱动因素

1. 核心行为的可测试性——无需进程级 CLI 编排即可测试。
2. 随着功能扩展的长期可维护性。
3. 未来集成场景的可复用性（自动化、嵌入、其他前端）。
4. 领域逻辑与命令解析之间的关注点清晰分离。

## 备选方案

## 方案 A: 纯 CLI

将配置、请求管线、会话处理和输出格式化直接放在 binary command handlers 中实现。

优点：

- 在极小范围内初始实现更快。
- 初期更少的 crate/module 边界。

缺点：

- 单元测试更困难；业务逻辑容易依赖 CLI 进程上下文。
- 添加其他接口时复用成本高。
- command handlers 与领域行为紧耦合的风险增加。

## 方案 B: library+CLI

将领域逻辑放在 library crate 中，CLI 仅作为输入/输出和命令路由的适配层。

优点：

- 通过隔离模块获得更好的核心逻辑单元测试覆盖。
- 解析、编排和领域操作之间边界更清晰。
- 支持未来通过其他接口复用，无需大规模重构。

缺点：

- 前期设计和模块规划成本略高。
- 需要纪律保持 CLI 层的轻薄。

## 决策

采用 `library+CLI`。

CrabClaw 将使用：

- `src/lib.rs` 作为核心模块（config、client、session、error、models）。
- `src/main.rs` 负责 CLI 解析并调用 library API。
- 集成测试验证 CLI 行为，单元测试验证 library 模块。

## 影响

正面：

- 通过专注的单元测试获得更高信心。
- 扩展命令或添加新前端时重构风险更低。
- 请求/响应处理的 API 边界更清晰。

负面：

- 早期 commit 中略多模板代码。
- 从一开始就需要明确的模块契约。

## 实现说明

1. 命令解析和终端格式化仅保留在 binary 层。
2. API client、配置解析和会话持久化保留在 library 模块中。
3. 优先使用依赖注入来简化 HTTP client 和存储接口的测试。

## 重新审视触发条件

在以下情况下重新审视本 ADR：

1. 项目范围永久缩减至一个无复用需求的静态命令。
2. 模块边界带来的运行时或编译复杂度与交付价值不成比例。
